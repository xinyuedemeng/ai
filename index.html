<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D粒子自动变换与手势控制</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入 Three.js 核心库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- 引入 OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- 引入 dat.GUI -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <!-- 引入 MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        
        /* GUI 容器样式调整 */
        .dg.ac { z-index: 2000 !important; }
        .dg.main { border-radius: 8px; overflow: hidden; }

        .fullscreen-btn {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            color: white;
            padding: 10px 20px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 30px;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.3s;
            font-size: 0.9rem;
            letter-spacing: 1px;
        }
        .fullscreen-btn:hover { background-color: rgba(255, 255, 255, 0.25); transform: translateX(-50%) scale(1.05); }

        /* 隐藏摄像头预览，因为我们移除了摄像头模式，只保留手势控制的后台处理 */
        .camera-preview {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 90px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            background: #000;
            transform: scaleX(-1);
            opacity: 0.3; /* 降低不透明度，不干扰视觉 */
            transition: opacity 0.3s;
        }
        .camera-preview:hover { opacity: 1; }
        #input_video { width: 100%; height: 100%; object-fit: cover; }
        #output_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        /* 形状切换提示 */
        .shape-toast {
            position: fixed;
            top: 15%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.0);
            text-shadow: 0 0 20px rgba(0, 255, 200, 0.8);
            color: rgba(255, 255, 255, 0.9);
            font-size: 2.5rem;
            font-weight: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.8s;
            z-index: 2000;
            letter-spacing: 4px;
            text-transform: uppercase;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="container"></div>

    <button id="fullscreenButton" class="fullscreen-btn">
        ⛶ FULLSCREEN
    </button>

    <div id="shapeToast" class="shape-toast">Solar System</div>

    <!-- 保留摄像头用于手势控制，但视觉上缩小 -->
    <div class="camera-preview" id="cameraPreview">
        <video id="input_video" playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <script>
        // --- 全局变量 ---
        let scene, camera, renderer, controls, gui;
        let particles, geometry, material;
        let clock = new THREE.Clock();

        const particleCount = 45000; 
        
        let positions = new Float32Array(particleCount * 3);
        let targetPositions = new Float32Array(particleCount * 3);
        let originalPositions = new Float32Array(particleCount * 3);
        let colorsAttribute; 
        
        let mouse = { x: 0, y: 0 };
        let handDistanceLerp = 0; 
        let targetSpreadFactor = 0; 
        let currentShapeKey = 'solarSystem';
        let isHandsDetected = false; 

        // 自动变换相关变量
        let lastShapeChangeTime = 0;
        let shapeController; 
        
        // 摄像头处理相关
        let videoElement, canvasElement, canvasCtx;

        // GUI 控制参数
        const params = {
            shape: 'solarSystem', 
            autoChange: true, 
            size: 0.6,
            spreadFactor: 0.0, 
            diffusionIntensity: 20, 
            morphSpeed: 0.06, 
        };

        // --- 形状生成器 ---
        const ShapeGenerators = {
            cube: (positions) => {
                const size = 180;
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    positions[i3] = randomRange(-size/2, size/2);
                    positions[i3 + 1] = randomRange(-size/2, size/2);
                    positions[i3 + 2] = randomRange(-size/2, size/2);
                }
            },
            pyramid: (positions) => {
                const height = 200;
                const baseSize = 220;
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    const t = Math.random(); 
                    // 在截面正方形内随机采样
                    const x = randomRange(-baseSize/2, baseSize/2) * t;
                    const z = randomRange(-baseSize/2, baseSize/2) * t;
                    const y = height/2 - (height * t);
                    
                    positions[i3] = x;
                    positions[i3 + 1] = y;
                    positions[i3 + 2] = z;
                }
            },
            heart: (positions) => {
                const scale = 220;
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    const t = randomRange(0, Math.PI * 2);
                    const x = 16 * Math.sin(t) ** 3;
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                    
                    const z = randomRange(-8, 8); 
                    const thickScale = randomRange(0.8, 1.2); 
                    
                    positions[i3] = x * scale / 16 * thickScale;
                    positions[i3 + 1] = y * scale / 16 * thickScale;
                    positions[i3 + 2] = z * 4; 
                }
            },
            solarSystem: (positions) => {
                // 太阳及九大恒星(行星)
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    const r = Math.random();
                    
                    if (r < 0.1) {
                        // 太阳
                        const rad = 35;
                        const phi = Math.acos(2 * Math.random() - 1);
                        const theta = Math.random() * Math.PI * 2;
                        positions[i3] = rad * Math.sin(phi) * Math.cos(theta);
                        positions[i3 + 1] = rad * Math.sin(phi) * Math.sin(theta);
                        positions[i3 + 2] = rad * Math.cos(phi);
                    } else {
                        // 9条轨道 (简化模拟)
                        const orbitIndex = Math.floor(randomRange(0, 9)); 
                        const baseRadius = 50 + orbitIndex * 25; // 轨道半径递增
                        const width = 8;
                        
                        // 在轨道环内随机
                        const angle = Math.random() * Math.PI * 2;
                        const radius = baseRadius + randomRange(-width, width);
                        
                        const x = radius * Math.cos(angle);
                        const z = radius * Math.sin(angle);
                        const y = randomRange(-2, 2); // 扁平轨道

                        positions[i3] = x;
                        positions[i3 + 1] = y;
                        positions[i3 + 2] = z;
                    }
                }
            },
            star: (positions) => {
                // 五角星体 (3D Extruded Star)
                const rOuter = 120;
                const rInner = 50;
                const depth = 40;
                
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    
                    // 生成2D五角星形状的点
                    let angle = Math.random() * Math.PI * 2;
                    // 将角度归一化到 0 - 2PI/5
                    const segment = Math.PI * 2 / 5;
                    const localAngle = angle % segment;
                    
                    // 简单的五角星极坐标逻辑不太好写，这里用几何法：
                    // 在5个三角形内随机采样
                    const tipIndex = Math.floor(Math.random() * 5);
                    const a1 = (tipIndex * 2 * Math.PI) / 5; // 顶点角度
                    const a2 = ((tipIndex * 2 + 1) * Math.PI) / 5; // 凹点角度(右)
                    const a3 = ((tipIndex * 2 - 1) * Math.PI) / 5; // 凹点角度(左)
                    
                    // 随机决定是在左半边还是右半边三角形
                    const isRight = Math.random() > 0.5;
                    const targetAngle = isRight ? a2 : a3;
                    
                    // 三角形插值
                    const u = Math.random();
                    const v = Math.random();
                    
                    // 顶点
                    const pTipX = Math.cos(a1) * rOuter;
                    const pTipY = Math.sin(a1) * rOuter;
                    // 凹点
                    const pInnerX = Math.cos(targetAngle) * rInner;
                    const pInnerY = Math.sin(targetAngle) * rInner;
                    // 中心
                    const pCenterX = 0;
                    const pCenterY = 0;
                    
                    // 重心坐标采样
                    let s = Math.random();
                    let t = Math.random();
                    if (s + t > 1) { s = 1 - s; t = 1 - t; }
                    
                    const x = pCenterX + s * (pTipX - pCenterX) + t * (pInnerX - pCenterX);
                    const y = pCenterY + s * (pTipY - pCenterY) + t * (pInnerY - pCenterY);
                    
                    positions[i3] = x;
                    positions[i3 + 1] = y;
                    positions[i3 + 2] = randomRange(-depth/2, depth/2);
                }
            },
            spaceship: (positions) => {
                // 星际飞船
                for(let i=0; i<particleCount; i++) {
                    const i3 = i*3;
                    const r = Math.random();
                    
                    if (r < 0.6) {
                        // 机身 (Fuselage) - 沿X轴拉长
                        const len = 140;
                        const x = randomRange(-len, len);
                        // 半径随位置变化，形成流线型
                        // 头部(正X)尖，中间胖，尾部(负X)稍收
                        const t = (x + len) / (2 * len); // 0 to 1
                        const radius = 35 * Math.sin(t * Math.PI) * (0.8 + 0.2*t); 
                        
                        const angle = Math.random() * Math.PI * 2;
                        const rad = Math.random() * radius;
                        
                        positions[i3] = x;
                        positions[i3+1] = rad * Math.cos(angle);
                        positions[i3+2] = rad * Math.sin(angle);
                    } else if (r < 0.9) {
                        // 机翼 (Wings)
                        const x = randomRange(-60, 80);
                        const wingSpan = 120 * (1 - (x + 60)/140); // 后掠翼
                        const z = randomRange(-wingSpan, wingSpan);
                        // 避开机身内部
                        if (Math.abs(z) > 20) {
                            positions[i3] = x;
                            positions[i3+1] = randomRange(-2, 2); // 机翼厚度
                            positions[i3+2] = z;
                        } else {
                            positions[i3] = x;
                            positions[i3+1] = randomRange(-5, 5);
                            positions[i3+2] = randomRange(-5, 5);
                        }
                    } else {
                        // 引擎尾焰 (Engine Glow)
                        const x = randomRange(-160, -140);
                        const radius = randomRange(0, 25);
                        const angle = Math.random() * Math.PI * 2;
                        positions[i3] = x;
                        positions[i3+1] = radius * Math.cos(angle);
                        positions[i3+2] = radius * Math.sin(angle);
                    }
                }
            }
        };

        function randomRange(min, max) { return Math.random() * (max - min) + min; }

        // --- 颜色更新逻辑 ---
        function updateColors(shape) {
            const colors = geometry.attributes.color.array;
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const x = targetPositions[i3];
                const y = targetPositions[i3 + 1];
                const z = targetPositions[i3 + 2];
                const dist = Math.sqrt(x*x + y*y + z*z);

                let r, g, b;

                if (shape === 'cube') {
                    // 赛博朋克方块：紫色边缘，蓝色内部
                    const maxDim = Math.max(Math.abs(x), Math.abs(y), Math.abs(z));
                    if (maxDim > 80) { r=0.8; g=0.0; b=1.0; } // 边缘紫
                    else { r=0.0; g=0.8; b=1.0; } // 内部蓝
                } else if (shape === 'pyramid') {
                    // 金字塔：金色 -> 底部青色
                    const hFactor = (y + 100) / 200;
                    r = 1.0 - hFactor * 0.8; 
                    g = 0.8; 
                    b = 0.2 + hFactor * 0.8;
                } else if (shape === 'heart') {
                    // 爱心：红粉渐变
                    r = 1.0; g = 0.1; b = 0.3 + (y/200) * 0.6;
                } else if (shape === 'solarSystem') {
                    if (dist < 40) { // 太阳
                        r = 1.0; g = 0.5 + Math.random()*0.3; b = 0.0; 
                    } else { // 行星轨道
                        // 根据半径分配颜色
                        const radius = Math.sqrt(x*x + z*z);
                        const colorHash = Math.floor(radius / 25);
                        if (colorHash % 3 === 0) { r=0.4; g=0.6; b=1.0; } // 蓝星
                        else if (colorHash % 3 === 1) { r=0.8; g=0.7; b=0.4; } // 土黄星
                        else { r=0.8; g=0.3; b=0.3; } // 红星
                    }
                } else if (shape === 'star') {
                    // 五角星：金光闪闪
                    r = 1.0; g = 0.9; b = 0.2 + Math.random()*0.3;
                } else if (shape === 'spaceship') {
                    // 飞船：机身灰白，尾焰蓝
                    if (x < -130) { // 尾焰
                        r = 0.2; g = 0.6; b = 1.0; 
                    } else {
                        r = 0.8; g = 0.85; b = 0.9; // 机身
                        // 机翼边缘加点警示红
                        if (Math.abs(z) > 60 && Math.random()>0.8) { r=1.0; g=0.2; b=0.2; }
                    }
                } else {
                    r = 1; g = 1; b = 1;
                }

                colors[i3] = Math.min(1, r + (Math.random()-0.5)*0.15);
                colors[i3 + 1] = Math.min(1, g + (Math.random()-0.5)*0.15);
                colors[i3 + 2] = Math.min(1, b + (Math.random()-0.5)*0.15);
            }
            geometry.attributes.color.needsUpdate = true;
        }

        // --- 辅助功能 ---
        function showToast(text) {
            const toast = document.getElementById('shapeToast');
            toast.textContent = text;
            toast.style.opacity = '1';
            setTimeout(() => { toast.style.opacity = '0'; }, 3000);
        }

        // --- Three.js 初始化 ---
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x050510, 200, 1200);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.z = 400;
            camera.position.y = 100;
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true; 
            controls.autoRotateSpeed = 0.5;

            initParticles();
            initGUI();
            setShape(params.shape);
            
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('touchmove', onTouchMove);
            document.getElementById('fullscreenButton').addEventListener('click', toggleFullscreen);

            animate();
        }

        function initParticles() {
            geometry = new THREE.BufferGeometry();
            const colors = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount * 3; i++) colors[i] = 1.0;

            ShapeGenerators.cube(originalPositions); // 默认位置
            positions.set(originalPositions); 
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            colorsAttribute = geometry.attributes.color;

            material = new THREE.PointsMaterial({
                size: params.size,
                vertexColors: true,
                transparent: true,
                opacity: 0.85,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }
        
        function setShape(shapeKey) {
            if (ShapeGenerators[shapeKey]) {
                ShapeGenerators[shapeKey](targetPositions);
                currentShapeKey = shapeKey;
                
                updateColors(shapeKey);

                const displayName = {
                    'solarSystem': 'Solar System',
                    'pyramid': 'Pyramid',
                    'cube': 'Cube',
                    'heart': 'Heart',
                    'star': 'Star',
                    'spaceship': 'Spaceship'
                }[shapeKey] || shapeKey;
                
                showToast(displayName);
            }
        }

        function initGUI() {
            gui = new dat.GUI({ autoPlace: false });
            gui.domElement.style.position = 'fixed';
            gui.domElement.style.top = '10px';
            gui.domElement.style.right = '10px';
            document.body.appendChild(gui.domElement);

            const keys = Object.keys(ShapeGenerators);
            shapeController = gui.add(params, 'shape', keys).name('Shape').onChange(setShape);
            gui.add(params, 'autoChange').name('Auto Transform');
            gui.add(params, 'size', 0.1, 5).name('Particle Size').onChange(v => { material.size = v; });
            gui.add(params, 'spreadFactor', 0.0, 1.0).name('Hand Control').listen(); 
            
            gui.close(); 
        }

        // --- MediaPipe Hands ---
        function initCamera() {
            videoElement = document.getElementById('input_video');
            canvasElement = document.getElementById('output_canvas');
            canvasCtx = canvasElement.getContext('2d');

            function onResults(results) {
                // 只绘制骨架用于调试，不绘制原图，节省性能且保持界面干净
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    isHandsDetected = true;
                    // 绘制简易骨架
                    for (const landmarks of results.multiHandLandmarks) {
                        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 1});
                    }

                    if (results.multiHandLandmarks.length === 2) {
                        const h1 = results.multiHandLandmarks[0][0]; 
                        const h2 = results.multiHandLandmarks[1][0]; 
                        const dist = Math.sqrt(Math.pow(h1.x - h2.x, 2) + Math.pow(h1.y - h2.y, 2));
                        let factor = (dist - 0.15) / (0.6 - 0.15); 
                        targetSpreadFactor = Math.max(0, Math.min(1, factor));
                    } else {
                        const h = results.multiHandLandmarks[0];
                        const dist = Math.sqrt(Math.pow(h[4].x - h[8].x, 2) + Math.pow(h[4].y - h[8].y, 2));
                        let factor = (dist - 0.05) / (0.25 - 0.05);
                        targetSpreadFactor = Math.max(0, Math.min(1, factor));
                    }
                } else {
                    isHandsDetected = false;
                }
            }

            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(onResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 160, 
                height: 120
            });
            
            cameraUtils.start().catch(err => console.error(err));
        }

        // --- 核心动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const time = clock.getElapsedTime();

            if (params.autoChange) {
                if (time - lastShapeChangeTime > 10) {
                    lastShapeChangeTime = time;
                    const keys = Object.keys(ShapeGenerators);
                    let nextShape = keys[Math.floor(Math.random() * keys.length)];
                    while(nextShape === currentShapeKey && keys.length > 1) {
                        nextShape = keys[Math.floor(Math.random() * keys.length)];
                    }
                    params.shape = nextShape;
                    setShape(nextShape);
                    if(shapeController) shapeController.updateDisplay();
                }
            } else {
                lastShapeChangeTime = time;
            }

            // 手势控制交互
            if (isHandsDetected) {
                params.spreadFactor += (targetSpreadFactor - params.spreadFactor) * 0.1;
            }
            handDistanceLerp += (params.spreadFactor - handDistanceLerp) * params.morphSpeed;
            
            // 粒子位置更新与扩散动画
            const positionsAttribute = geometry.attributes.position;
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                const targetX = targetPositions[i3];
                const targetY = targetPositions[i3 + 1];
                const targetZ = targetPositions[i3 + 2];
                
                // 扩散计算：根据原始位置 + 波动
                const spreadX = originalPositions[i3] * (2 + Math.sin(time + i*0.01)) + Math.cos(time * 2 + i) * params.diffusionIntensity * 5;
                const spreadY = originalPositions[i3+1] * (2 + Math.cos(time + i*0.01)) + Math.sin(time * 2 + i) * params.diffusionIntensity * 5;
                const spreadZ = originalPositions[i3+2] * (2 + Math.sin(time * 0.5)) + Math.cos(time + i) * params.diffusionIntensity * 5;

                const currentX = THREE.MathUtils.lerp(targetX, spreadX, handDistanceLerp);
                const currentY = THREE.MathUtils.lerp(targetY, spreadY, handDistanceLerp);
                const currentZ = THREE.MathUtils.lerp(targetZ, spreadZ, handDistanceLerp);

                positionsAttribute.array[i3] = currentX;
                positionsAttribute.array[i3 + 1] = currentY;
                positionsAttribute.array[i3 + 2] = currentZ;
            }

            positionsAttribute.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function onMouseMove(event) {
            if (!isHandsDetected) {
                mouse.x = event.clientX;
                mouse.y = event.clientY;
                params.spreadFactor = 1 - (mouse.y / window.innerHeight); 
                params.spreadFactor = Math.max(0, Math.min(1, params.spreadFactor)); 
            }
        }
        function onTouchMove(event) {
            if (event.touches.length > 0 && !isHandsDetected) {
                mouse.x = event.touches[0].clientX;
                mouse.y = event.touches[0].clientY;
                params.spreadFactor = 1 - (mouse.y / window.innerHeight); 
                params.spreadFactor = Math.max(0, Math.min(1, params.spreadFactor)); 
            }
        }
        function toggleFullscreen() {
            if (!document.fullscreenElement) document.body.requestFullscreen().catch(e=>console.log(e));
            else document.exitFullscreen();
        }

        window.onload = function () {
            initThree();
            setTimeout(initCamera, 1000); 
        }
    </script>
</body>
</html>
